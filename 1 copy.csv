7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 2, 0, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 3, 2, 1, 2, 1, 1, 1, 1, 2, 1, 2, 2, 3, 3, 2, 2, 4, 2, 2, 18, 9, 5, 3, 3, 26, 4, 5, 2, 17, 3, 2, 3, 3, 22, 2, 4, 16, 18, 3, 4, 2, 2, 3, 4, 7, 5, 2, 2, 2, 2, 3, 3, 5, 3, 3, 3, 2, 2, 4, 6, 8, 4, 3, 2, 2, 3, 4, 4, 6, 4, 5, 3, 3, 3, 6, 4, 7, 5, 5, 3, 4, 4, 4, 5, 7, 9, 4, 5, 6, 2, 4, 6, 7, 9, 8, 3, 3, 7, 2, 3, 10, 6, 11, 5, 7, 5, 2, 3, 6, 8, 7, 9, 6, 3, 3, 5, 4, 5, 4, 11, 11, 10, 5, 6, 5, 5, 4, 5, 6, 12, 15, 6, 4, 4, 5, 6, 4, 6, 13, 10, 8, 7, 9, 10, 7, 10, 10, 11, 11, 13, 20, 13, 7, 4, 5, 12, 6, 6, 7, 10, 13, 8, 11, 6, 5, 5, 5, 23, 16, 13, 16, 48, 111, 121, 75, 20, 11, 5, 5, 9, 10, 16, 5, 8, 9, 6, 6, 4, 5, 8, 8, 10, 16, 14, 7, 7

    void Tracking::SonarFromLastFrame()
    {
        // 存储上一个关键帧的地址，修改为 KeyFrame* 类型
        static KeyFrame *previousKeyFrame = nullptr; // 使用 KeyFrame* 类型来匹配 mpLastKeyFrame

        if (!mCurrentFrame.mpPrevFrame)
        {
            Verbose::PrintMess("No previous frame", Verbose::VERBOSITY_NORMAL);
            return;
        }

        mvSonarFromLastFrame.clear();
        mvSonarFromLastFrame.reserve(mlQueueSonarData.size());

        while (true)
        {
            // 使用 unique_lock 来加锁队列操作部分
            std::unique_lock<std::mutex> lock(mMutexSonarQueue);

            // 如果队列为空，则跳出循环
            if (mlQueueSonarData.empty())
                break;

            Sonar::SonarData *sonardata = &mlQueueSonarData.front();
            std::cout.precision(19);

            // 根据时间戳来处理深度数据
            if (sonardata->timestamp < mCurrentFrame.mpPrevFrame->mTimeStamp)
            {
                mlQueueSonarData.pop_front(); // 丢弃过时的数据
            }
            else if (sonardata->timestamp < mCurrentFrame.mTimeStamp)
            {
                mvSonarFromLastFrame.push_back(*sonardata); // 添加有效数据
                mlQueueSonarData.pop_front();               // 从队列中移除处理过的数据
            }
            else if (sonardata->timestamp > mCurrentFrame.mTimeStamp)
            {
                break; // 时间戳大于当前帧时间戳，跳出循环
            }
        }

        // 这种方法可能会有Bug

        if (previousKeyFrame != mCurrentFrame.mpLastKeyFrame)
        {
            previousKeyFrame = mCurrentFrame.mpLastKeyFrame;
            mvSonarFromLastKF.clear();
            mvSonarFromLastKF.insert(mvSonarFromLastKF.end(), mvSonarFromLastFrame.begin(), mvSonarFromLastFrame.end());
            mCurrentFrame.mvSonarBetweenKF = mvSonarFromLastKF;
        }
        else
        {
            mvSonarFromLastKF.insert(mvSonarFromLastKF.end(), mvSonarFromLastFrame.begin(), mvSonarFromLastFrame.end());
            mCurrentFrame.mvSonarBetweenKF = mvSonarFromLastKF;
        }

    }